## os包

os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。
1. 程序的命令行参数可从 os 包的 Args 变量获取, `os.Args` 变量是字符串的切片（slice），其中 `os.Args[0]`是命令本身的名字，其他的元素是程序启动时传递的参数。

## sort包

这个是内置的切片排序包，可以对一些基本的可以比较大小的类型的切片进行排序，也可以通过实现排序接口的几个特定方法实现自定义排序。

常用方法：`sort.Ints([]int)`, `sort.Strings([]string)`, 默认按照升序进行排列。

如果需要按照降序排列或者采用别的方法，通常需要借助 `sort.Slice()`。

```go
// 实现降序排列

```

## log包

日志包提供了结构体类型 `Logger`, 是`log`包的基础部分。这个结构体表示一个日志对象，通过`io.Writer`进行日志输出，每条记录都会简单的调用`io.Writer`的`write`方法。一个`Logger`可以被多个`goroutines`同步执行

```go
// A Logger represents an active logging object that generates lines of
// output to an io.Writer. Each logging operation makes a single call to
// the Writer's Write method. A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type Logger struct {
	mu     sync.Mutex // ensures atomic writes; protects the following fields
	prefix string     // prefix on each line to identify the logger (but see Lmsgprefix)
	flag   int        // properties
	out    io.Writer  // destination for output
	buf    []byte     // for accumulating text to write
}
```

flag的值在包中定义了一些常量，作用是标识日志信息中附加携带的信息。通过设置不同的位来表达不同的行为，例如指定日期、时间，行号、文件名等。`LstdFlags`为默认的flag，输出日期和时间两个信息。

```go
// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// With the exception of the Lmsgprefix flag, there is no
// control over the order they appear (the order listed here)
// or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	Lmsgprefix                    // move the "prefix" from the beginning of the line to before the message
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)
```

日志输出方法：

```go
func (l *Logger) Print(v ...interface{}) //直接打印输出
func (l *Logger) Fatal(v ...interface{}) //输出日志后立即结束程序
func (l *Logger) Panic(v ...interface{}) //输出日志后抛出异常
```

`log`包定义了一个New方法，并通过默认flag初始化了一个全局的私有logger。当我们使用 `log.Println("Hello,World!)`底层调用的就是这个默认的 `std`结构体，我们也可以利用 `New`方法配置创建自己的logger, 或者使用`SetOutput`,`SetFlags`等方法单独设置。

```go
func New(out io.Writer, prefix string, flag int) *Logger {
	return &Logger{out: out, prefix: prefix, flag: flag}
}

var std = New(os.Stderr, "", LstdFlags)

// 单独方法设置logger
func (l *Logger) SetOutput(w io.Writer)
func (l *Logger) SetFlags(flag int)
func (l *Logger) SetPrefix(prefix string)
```

日志输出方法逻辑：`Logger`结构体的日志输出方法，都是通过调用`func (l *Logger) Output(calldepth int, s string) error`实现的，内部主要完成以下事情：

1. 获取当前事件
2. 对 Logger实例进行加锁操作
3. 判断Logger的标志位是否包含 Lshortfile 或 Llongfile,　如果包含进入步骤4, 如果不包含进入步骤5
4. 获取当前函数调用所在的文件和行号信息
5. 格式化数据，并将数据写入到 l.out 中，完成输出
6. 解锁操作


## io包

## strings包

1. `strings.Join`函数：连接数组或者切片形成新的字符串
2. `strings.Map`函数：对字符串中的每个字符调用对应的函数，例如: `strings.Map(func(r rune) rune { return r + 1 }, "ABC")`

## strconv包



## bufio包

这个包的核心作用是利用缓冲区减少IO操作次数，提升读写性能。它提供了 `bufio.Reader` 和 `bufio.Writer` 类型，其内部分别包装了`io.Reader` 和 `io.Writer` 对象，同时分别实现了 `io.Reader` 和 `io.Writer` 接口。同时，该包为文本I/O提供了一些便利操作。


### bufio.Reader

带缓冲区的Reader

```go
// bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口
type Reader struct {
    buf []byte    // 缓存
    rd  io.Reader // 底层的 io.Reader
    // r：从 buf 中读取的字节（偏移）；w：buf 中写入内容的偏移；
    // w - r 是 buf 中可被读的长度（缓存数据的大小），也是 Buffered() 方法的返回值
    r, w         int
    err          error // 读过程中遇到的错误
    lastByte     int   // 最后一次读到的字节值，-1 是无效值
    lastRuneSize int   // 最后一次读到的 Rune 的大小，只有 ReadRune 操作才会修改该值，-1 是无效值
}
```

bufio 包提供了两个实例化 Reader 对象的函数。

```go
// 创建一个具有默认大小缓存、从 r 读取的 *Reader，默认缓存大小为 4096 字节
func NewReader(r io.Reader) *Reader

// 创建一个具有最少有 size 大小的缓存、从 r 读取的 *Reader
// 如果参数 r 已经是一个具有足够大缓存的 *Reader 类型值，会返回 r
func NewReaderSize(r io.Reader, size int) *Reader
```

读操作方法

```go
// 从底层输入流读取最多 len(p) 个字节数据写入到 p 中，返回读取的字节数 n 和遇到的任何错误 err
// 读取到输入流结尾，n 可能返回非 0，err 返回 nil 或者 io.EOF，但是下次调用肯定返回 (0, io.EOF)
func (b *Reader) Read(p []byte) (n int, err error)

// 读取并返回一个字节。如果没有可用的数据，会返回错误
func (b *Reader) ReadByte() (c byte, err error)

// 还原最近一次读取操作读出的最后一个字节，相当于让读偏移量 r 前移一个字节
// 连续两次 UnreadByte 操作，而中间没有任何读取操作，会返回错误
func (b *Reader) UnreadByte() error

// 读取一个 utf-8 编码的 unicode 码值，返回该码值、其编码长度和可能的错误
// 如果 utf-8 编码非法，读取位置只移动 1 字节，返回 U+FFFD，返回值 size 为 1 而 err 为 nil。如果没有可用的数据，会返回错误
func (b *Reader) ReadRune() (r rune, size int, err error)

// 还原前一次 ReadRune 操作读取的 unicode 码值，相当于让读偏移量 r 前移一个码值长度
// 需要注意 UnreadRune 方法调用前必须调用 ReadRune 方法（从这点看，UnreadRune 比 UnreadByte 严格很多）
func (b *Reader) UnreadRune() error

// 读取直到第一次遇到 delim 字节，返回一个包含已读取的数据和 delim 字节的切片
// 如果 ReadBytes 方法在读取到 delim 之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是 io.EOF）
// 当且仅当 ReadBytes 方法返回的切片不以 delim 结尾时，会返回一个非 nil 的错误
func (b *Reader) ReadBytes(delim byte) (line []byte, err error)

// 读取直到第一次遇到 delim 字节，返回一个包含已读取的数据和 delim 字节的字符串
// 如果 ReadString 方法在读取到 delim 之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是 io.EOF）
// 当且仅当 ReadString 方法返回的切片不以 delim 结尾时，会返回一个非 nil 的错误
func (b *Reader) ReadString(delim byte) (line string, err error)

// 返回输入流的下 n 个字节，而不会移动读偏移量 r。返回的 []byte 是 buf 的引用，所以只在下一次调用读取操作前合法
// 如果 Peek() 返回的切片长度比 n 小，它也会返会一个错误说明原因。如果 n 比缓存尺寸还大，返回的错误将是 ErrBufferFull
func (b *Reader) Peek(n int) ([]byte, error)
```

### bufio.Writer

bufio 包同样提供了两个实例化 Writer 对象的函数。

```go
// 创建一个具有默认大小缓存、写入 w 的 *Writer，默认缓存大小为 4096 字节
func NewWriter(w io.Writer) *Writer

// 创建一个具有最少有 size 尺寸的缓存、写入 w 的 *Writer
// 如果参数 w 已经是一个具有足够大缓存的 *Writer 类型值，会返回 w
func NewWriterSize(w io.Writer, size int) *Writer
```

写操作的常用方法：

```go
// 将 p 的内容写入缓存，返回写入的字节数。如果返回值 n < len(p)，返回一个错误说明原因
func (b *Writer) Write(p []byte) (n int, err error)

// 将单个字节写入缓存
func (b *Writer) WriteByte(c byte) error

// 将一个 unicode 码值写入缓存，返回写入的字节数和可能的错误
func (b *Writer) WriteRune(r rune) (size int, err error)

// 将一个字符串写入缓存，返回写入的字节数。如果返回值 n < len(s)，返回一个错误说明原因
func (b *Writer) WriteString(s string) (n int, err error)

// 缓存满时，写操作会自动调用 Flush 方法。该方法将缓存数据刷新到底层的 io.Writer 对象
// 在所有的写操作完成之后，应该调用 Flush 方法使得缓存都写入底层的 io.Writer 对象
func (b *Writer) Flush() error
```

### bufio.Scanner

`Scanner`是`bufio`包下的类型，在处理文件中以分隔符分隔的文本时很有用。通常我们使用换行符作为分隔符将文件内容分成多行。在 CSV 文件中，逗号一般作为分隔符。`os.File`文件可以被包装成`bufio.Scanner`，它就像一个缓存 Reader。我们会调用 `Scan()`方法去读取下一个分隔符，使用`Text()`或者`Bytes()`获取读取的数据。

分隔符可以不是一个简单的字节或者字符，有一个特殊的方法可以实现分隔符的功能，以及将指针移动多少，返回什么数据。如果没有定制的`SplitFunc`提供，缺省的`ScanLines()`会使用 newline 字符作为分隔符，其它的分隔函数还包括`ScanRunes()`和`ScanWords()`，皆在 bufio 包中。

```go
// SplitFunc 类型代表用于对输出作词法分析的分割函数
// 参数 data 是尚未处理的数据的一个开始部分的切片，参数 atEOF 表示是否 Reader 接口不能提供更多的数据。
// 返回值是解析位置前进的字节数，将要返回给调用者的 token 切片，以及可能遇到的错误。如果数据不足以（保证）
// 生成一个完整的 token，例如需要一整行数据但 data 里没有换行符，SplitFunc 可以返回(0, nil, nil)来告
// 诉 Scanner 读取更多的数据写入切片然后用从同一位置起始、长度更长的切片再试一次（调用 SplitFunc 类型函数）。
// 如果返回值 err 非 nil，扫描将终止并将该错误返回给 Scanner 的调用者。
// 除非 atEOF 为真，永远不会使用空切片 data 调用 SplitFunc 类型函数。然而，如果 atEOF 为真，data 却
// 可能是非空的、且包含着未处理的文本。
type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)

// 下面是 bufio 包定义的用于 Scanner 类型的分割函数（符合 SplitFunc）

// 本函数会将每个字节作为一个 token 返回
func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)

// 本函数会将每个 utf-8 编码的 unicode 码值作为一个 token 返回。
// 本函数返回的 rune 序列和 range 一个字符串的输出 rune 序列相同。错误的 utf-8 编码会翻译为 U+FFFD = 
// "\xef\xbf\xbd"，但只会消耗一个字节。调用者无法区分正确编码的 rune 和错误编码的 rune。
func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)

// 本函数会将空白（参见unicode.IsSpace）分隔的片段（去掉前后空白后）作为一个 token 返回。本函数永远不会返回空字符串
func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)

// 本函数会将每一行文本去掉末尾的换行标记作为一个 token 返回，返回的行可以是空字符串。
// 换行标记为一个可选的回车后跟一个必选的换行符。最后一行即使没有换行符也会作为一个 token 返回
func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)
```

```go
// bufio.Scanner 类型提供了方便的读取数据的接口，如从换行符分隔的文本里读取每一行
type Scanner struct {
    r            io.Reader // The reader provided by the client.
    split        SplitFunc // The function to split the tokens.
    maxTokenSize int       // Maximum size of a token; modified by tests.
    token        []byte    // Last token returned by split.
    buf          []byte    // Buffer used as argument to split.
    start        int       // First non-processed byte in buf.
    end          int       // End of data in buf.
    err          error     // Sticky error.
    empties      int       // Count of successive empty tokens.
    scanCalled   bool      // Scan has been called; buffer is in use.
    done         bool      // Scan has finished.
}

// 创建并返回一个从 r 读取数据的 Scanner，默认的分割函数是 ScanLines
func NewScanner(r io.Reader) *Scanner

// 设置该 Scanner 的分割函数。本方法必须在 Scan 之前调用
func (s *Scanner) Split(split SplitFunc)

// 获取当前位置生成的 token（该 token 可以通过 Bytes 或 Text 方法获得），并让 Scanner 的扫描位置移动到下一个 token。
// 当扫描因为抵达输入流结尾或者遇到错误而停止时，本方法会返回 false。在 Scan 方法返回 false 后，Err 方
// 法将返回扫描时遇到的任何错误；除非是 io.EOF，此时 Err 会返回 nil
func (s *Scanner) Scan() bool

// 返回最近一次 Scan 调用生成的 token。底层数组指向的数据可能会被下一次 Scan 的调用重写
func (s *Scanner) Bytes() []byte

// 返回最近一次 Scan 调用生成的 token，会申请创建一个字符串保存 token 并返回该字符串
func (s *Scanner) Text() string

// 返回 Scanner 遇到的第一个非 EOF 的错误
func (s *Scanner) Err() error
```


## flag包

## time包

### 基础

time包的核心结构是 `time.Time`, 如下：

```go
type Time struct {
    wall uint64
    ext  int64
    loc *Location
}
```

格式化和解析：
```go
t := time.Date(2011, time.Month(3), 12, 15, 30, 20, 0, now.Location())
fmt.Println(t.Format("2006-01-02 15:04:05"))
t1, _ := time.Parse("2006-01-02 15:04:05", "2021-01-10 15:01:02")
t2, _ := time.ParseInLocation("2006-01-02 15:04:05", time.Now().Format("2006-01-02 15:04:05"), time.Local)
fmt.Println(t2) 
```

`time.Now()` 使用的 CST(中国标准时间)，而 `time.Parse()` 默认的是 UTC(零时区)，它们相差 8 小时。所以解析时常用 `time.ParseInLocation()`，可以指定时区。

### UTC/GMT/CST

1. UTC(世界标准时间): 协调世界时，又称世界标准时间或世界协调时间，简称UTC（从英文“Coordinated Universal Time”／法文“Temps Universel Coordonné”而来），是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间
2. GMT: 格林尼治平时（又称格林尼治平均时间或格林尼治标准时间，旧译格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能与实际的太阳时有误差，最大误差达16分钟。由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治时间已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）。
3. CST(北京时间): 北京时间，China Standard Time，中国标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8。不过这个CST这个缩写比较纠结的是它可以同时代表四个不同的时间： Central Standard Time (USA) UT-6:00, Central Standard Time (Australia) UT+9:30, China Standard Time UT+8:00, Cuba Standard Time UT-4:00

### 计算、比较日期

进行日期计算的时候通常使用 `time`包的`Duration`类型，底层类型是 `int64`, 表示一段时间间隔，单位是 纳秒。可以使用 `time.ParseDuration` 获取一个时间间隔（需要注意这个函数仅支持小时h，分钟m、秒、毫秒、纳秒，不支持天），如果需要进行天以上级别的计算，可以使用`func (t Time) AddDate(years int, months int, days int) Time`。

```go
now := time.Now()
// 1小时1分1s之后
t0, _ := time.ParseDuration("1h1m1s")
m0 := now.Add(t0)
// 得到一年一个月一天之后的时间
m1 := now.AddDate(1,1,1)
```

> `time.Since()`返回当前时间与 t 的时间差，返回值是 Duration，`time.Until()`返回 t 与当前时间的时间差。

日期比较总共有三种，之前，之后和相等
```go
// 如果 t 代表的时间点在 u 之前，返回真；否则返回假。
func (t Time) Before(u Time) bool
// 如果 t 代表的时间点在 u 之后，返回真；否则返回假。
func (t Time) After(u Time) bool
// 比较时间是否相等，相等返回真；否则返回假。
func (t Time) Equal(u Time) bool
```

### 时区操作



## math包

### 随机数

初始化一个随机数生成器, 以时间作为seed

```go
seed := time.Now().UTC().UnixNano()
rng := rand.New(rand.NewSource(seed))
rng.Intn(100) // 生成[0,100)的随机整数，
```

## net/http包

`net/http`包提供了HTTP客户端和服务端的实现。

### http协议基础

HTTP协议是应用层协议，在通常情况下我们都会使用 TCP 作为底层的传输层协议传输数据包，但是 HTTP/3 在 UDP 协议上实现了新的传输层协议`QUIC`并使用`QUIC`传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上。
HTTP 协议目前主要还是跑在 TCP 协议上的，TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议2，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机3。因为 TCP 协议是基于字节流的，所以基于 TCP 协议的应用层协议都需要自己划分消息的边界。在应用层协议中，最常见的两种解决方案是**基于长度或者基于终结符（Delimiter）**。HTTP 协议其实同时实现了上述两种方案，在多数情况下 HTTP 协议都会在协议头中加入 Content-Length 表示负载的长度，消息的接收者解析到该协议头之后就可以确定当前 HTTP 请求/响应结束的位置，分离不同的 HTTP 消息。HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界

## net/url包

1. `url.QueryEscape`: 处理`?`和`&`之类的特殊字符, 执行转移操作
