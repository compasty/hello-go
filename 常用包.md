## os包

os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。
1. 程序的命令行参数可从 os 包的 Args 变量获取, `os.Args` 变量是字符串的切片（slice），其中 `os.Args[0]`是命令本身的名字，其他的元素是程序启动时传递的参数。

## sort包

这个是内置的切片排序包，可以对一些基本的可以比较大小的类型的切片进行排序，也可以通过实现排序接口的几个特定方法实现自定义排序。

常用方法：`sort.Ints([]int)`, `sort.Strings([]string)`, 默认按照升序进行排列。

如果需要按照降序排列或者采用别的方法，通常需要借助 `sort.Slice()`。

```go
// 实现降序排列

```

## log包

日志包提供了结构体类型 `Logger`, 是`log`包的基础部分。这个结构体表示一个日志对象，通过`io.Writer`进行日志输出，每条记录都会简单的调用`io.Writer`的`write`方法。一个`Logger`可以被多个`goroutines`同步执行

```go
// A Logger represents an active logging object that generates lines of
// output to an io.Writer. Each logging operation makes a single call to
// the Writer's Write method. A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type Logger struct {
	mu     sync.Mutex // ensures atomic writes; protects the following fields
	prefix string     // prefix on each line to identify the logger (but see Lmsgprefix)
	flag   int        // properties
	out    io.Writer  // destination for output
	buf    []byte     // for accumulating text to write
}
```

flag的值在包中定义了一些常量，作用是标识日志信息中附加携带的信息。通过设置不同的位来表达不同的行为，例如指定日期、时间，行号、文件名等。`LstdFlags`为默认的flag，输出日期和时间两个信息。

```go
// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// With the exception of the Lmsgprefix flag, there is no
// control over the order they appear (the order listed here)
// or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	Lmsgprefix                    // move the "prefix" from the beginning of the line to before the message
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)
```

日志输出方法：

```go
func (l *Logger) Print(v ...interface{}) //直接打印输出
func (l *Logger) Fatal(v ...interface{}) //输出日志后立即结束程序
func (l *Logger) Panic(v ...interface{}) //输出日志后抛出异常
```

`log`包定义了一个New方法，并通过默认flag初始化了一个全局的私有logger。当我们使用 `log.Println("Hello,World!)`底层调用的就是这个默认的 `std`结构体，我们也可以利用 `New`方法配置创建自己的logger, 或者使用`SetOutput`,`SetFlags`等方法单独设置。

```go
func New(out io.Writer, prefix string, flag int) *Logger {
	return &Logger{out: out, prefix: prefix, flag: flag}
}

var std = New(os.Stderr, "", LstdFlags)

// 单独方法设置logger
func (l *Logger) SetOutput(w io.Writer)
func (l *Logger) SetFlags(flag int)
func (l *Logger) SetPrefix(prefix string)
```

日志输出方法逻辑：`Logger`结构体的日志输出方法，都是通过调用`func (l *Logger) Output(calldepth int, s string) error`实现的，内部主要完成以下事情：

1. 获取当前事件
2. 对 Logger实例进行加锁操作
3. 判断Logger的标志位是否包含 Lshortfile 或 Llongfile,　如果包含进入步骤4, 如果不包含进入步骤5
4. 获取当前函数调用所在的文件和行号信息
5. 格式化数据，并将数据写入到 l.out 中，完成输出
6. 解锁操作


## io包

## strings包

1. `strings.Join`函数：连接数组或者切片形成新的字符串
2. `strings.Map`函数：对字符串中的每个字符调用对应的函数，例如: `strings.Map(func(r rune) rune { return r + 1 }, "ABC")`

## bufio包

这个包的核心作用是利用缓冲区减少IO操作次数，提升读写性能。

1. `bufio.NewScanner`: 

## flag包

## time包

### 基础

time包的核心结构是 `time.Time`, 如下：

```go
type Time struct {
    wall uint64
    ext  int64
    loc *Location
}
```

格式化和解析：
```go
t := time.Date(2011, time.Month(3), 12, 15, 30, 20, 0, now.Location())
fmt.Println(t.Format("2006-01-02 15:04:05"))
t1, _ := time.Parse("2006-01-02 15:04:05", "2021-01-10 15:01:02")
t2, _ := time.ParseInLocation("2006-01-02 15:04:05", time.Now().Format("2006-01-02 15:04:05"), time.Local)
fmt.Println(t2) 
```

`time.Now()` 使用的 CST(中国标准时间)，而 `time.Parse()` 默认的是 UTC(零时区)，它们相差 8 小时。所以解析时常用 `time.ParseInLocation()`，可以指定时区。

### UTC/GMT/CST

1. UTC(世界标准时间): 协调世界时，又称世界标准时间或世界协调时间，简称UTC（从英文“Coordinated Universal Time”／法文“Temps Universel Coordonné”而来），是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间
2. GMT: 格林尼治平时（又称格林尼治平均时间或格林尼治标准时间，旧译格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能与实际的太阳时有误差，最大误差达16分钟。由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治时间已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）。
3. CST(北京时间): 北京时间，China Standard Time，中国标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8。不过这个CST这个缩写比较纠结的是它可以同时代表四个不同的时间： Central Standard Time (USA) UT-6:00, Central Standard Time (Australia) UT+9:30, China Standard Time UT+8:00, Cuba Standard Time UT-4:00

### 计算、比较日期

进行日期计算的时候通常使用 `time`包的`Duration`类型，底层类型是 `int64`, 表示一段时间间隔，单位是 纳秒。可以使用 `time.ParseDuration` 获取一个时间间隔（需要注意这个函数仅支持小时h，分钟m、秒、毫秒、纳秒，不支持天），如果需要进行天以上级别的计算，可以使用`func (t Time) AddDate(years int, months int, days int) Time`。

```go
now := time.Now()
// 1小时1分1s之后
t0, _ := time.ParseDuration("1h1m1s")
m0 := now.Add(t0)
// 得到一年一个月一天之后的时间
m1 := now.AddDate(1,1,1)
```

> `time.Since()`返回当前时间与 t 的时间差，返回值是 Duration，`time.Until()`返回 t 与当前时间的时间差。

日期比较总共有三种，之前，之后和相等
```go
// 如果 t 代表的时间点在 u 之前，返回真；否则返回假。
func (t Time) Before(u Time) bool
// 如果 t 代表的时间点在 u 之后，返回真；否则返回假。
func (t Time) After(u Time) bool
// 比较时间是否相等，相等返回真；否则返回假。
func (t Time) Equal(u Time) bool
```

### 时区操作



## math包

### 随机数

初始化一个随机数生成器, 以时间作为seed

```go
seed := time.Now().UTC().UnixNano()
rng := rand.New(rand.NewSource(seed))
rng.Intn(100) // 生成[0,100)的随机整数，
```

## net/http包

`net/http`包提供了HTTP客户端和服务端的实现。

### http协议基础

HTTP协议是应用层协议，在通常情况下我们都会使用 TCP 作为底层的传输层协议传输数据包，但是 HTTP/3 在 UDP 协议上实现了新的传输层协议`QUIC`并使用`QUIC`传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上。
HTTP 协议目前主要还是跑在 TCP 协议上的，TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议2，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机3。因为 TCP 协议是基于字节流的，所以基于 TCP 协议的应用层协议都需要自己划分消息的边界。在应用层协议中，最常见的两种解决方案是**基于长度或者基于终结符（Delimiter）**。HTTP 协议其实同时实现了上述两种方案，在多数情况下 HTTP 协议都会在协议头中加入 Content-Length 表示负载的长度，消息的接收者解析到该协议头之后就可以确定当前 HTTP 请求/响应结束的位置，分离不同的 HTTP 消息。HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界

## net/url包

1. `url.QueryEscape`: 处理`?`和`&`之类的特殊字符, 执行转移操作
