# 基础拾遗

## 打印

`fmt.Printf`格式化打印：

1. `%T`: 用于显示一个值对应的数据类型
2. `%t`: 是用于打印布尔型数据
3. `%x`: 以十六进制的格式打印数组或slice全部的元素

## 声明

1. Go语言主要有四种类型的声明语句：`var`、`const`、`type`和`func`，分别对应变量、常量、类型和函数实体对象的声明。
2. `var`用来变量声明，变量会在声明时直接初始化，如果变量没有显式初始化，则被隐式地赋予其类型的 零值（zero value），数值类型是 0，字符串类型是空字符串 `""`, 布尔类型是false，接口或者引用类型(包含slice、指针、map、chan等)对应的是`nil`。
3. 符号`:=`是 短变量声明 的一部分，是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句，短变量声明只能用在函数的内部，不能用于包变量
4. 一般使用`type 类型名字 底层类型`进行类型声明，这样会创建一个新的类型名称，和现有类型具有相同的底层结构，新类型可以用来分隔不同概念的类型，这样即使底层类型相同也是不兼容的


## 可见性

1. 在函数内部定义的变量仅在函数内部有效，在函数外部定义的变量在当前包的所有文件中的都可以访问
2. 名字的开头字母大小写决定了名字在包外的可见性，大写字母开头的将是导出的，也就是可以被外部的包访问，例如`fmt`包的`Println`，包本身的名字一般总是用小写字母
3. 推荐使用 **驼峰式** 的命名方式


## new函数
表达式 `new(T)`会创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址（`*T`类型）

## 函数习惯

在GO语言中，经常会出现返回多个值的函数，通常这类函数会用额外的返回值来表达某种错误类型，一般来说返回一个error类型的错误，或者返回一个布尔值通常称为ok

```go
f, err = os.Open("foo.txt")
v, ok = m[key] // map lookup
v, ok = x.(T)  // type assertion
_, ok = m[key] 
```

## 包

一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径。每个包都对应一个独立的名字空间。例如，在`image`包中的`Decode`函数和在`unicode/utf16`包中的`Decode`函数是不同的。要在外部引用该函数，必须显式使用`image.Decode`或`utf16.Decode`形式访问。

在每个源文件的包声明前紧跟着的注释是包注释（§10.7.4）。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。

包的初始化：包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化。其次如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

特殊的init函数：有些包级别的变量需要比较复杂的初始化，此时可以使用特殊的`init`函数进行初始化，



# 复合数据类型

常用的复合类型有数组、slice、map和结构体。

## 数组

数组是由固定长度的特定类型元素组成的序列，默认情况下数组的每个元素都被初始化为元素类型对应的零值。

数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。

数组初始化方式:

```go
// 数组初始化
var b [3]float32 = [3]float32{1.1, 2.4, 5.6}
// 也可以指定索引进行对应初始化
var c [4]int = [4]int{0: 1, 2: 3}
r := [...]int{99: -1}
```

数组相等比较：只有当两个数组的长度相等，且所有元素都是相等的时候数组才是相等的。

数组作为参数传值时，GO语言会复制一个数组赋值给函数内部的参数变量，而不是传递指针或者引用。我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。

## slice

# 面向对象

一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。

## 方法基础

在GO语言中，函数声明时在名字前放一个变量就是一个方法，这个附加的参数会将该函数附加到这种类型上相当于为这种类型定义了一个独占的方法。

```go
type Point struct{ X, Y float64 }

func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

上面代码中附加的参数p, 叫做方法的接收器（receiver）。Go语言中不像其他语言使用`this`或者`self`作为接收器，而是可以任意选择名字，但是为了一致性和简短性，通常建议是选择类型的第一个字母。





# GO并发基础

## goroutines && channels
GO并发推荐使用“顺序通信进程”（communicating sequential processes， CSP），CSP是一种现代的并发编程模型，在这种模型中值会在不同的运行实例（goroutine）中传递。 

GO语言中每一个并发的执行单元叫作一个goroutine。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它**main goroutine**。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。

```go
f()    // call f(); wait for it to return
go f() // create a new goroutine that calls f(); don't wait
```

# 常用包

## os包

os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。
1. 程序的命令行参数可从 os 包的 Args 变量获取, `os.Args` 变量是字符串的切片（slice），其中 `os.Args[0]`是命令本身的名字，其他的元素是程序启动时传递的参数。

## strings包

1. `strings.Join`函数：连接数组或者切片形成新的字符串

## bufio包

这个包的核心作用是利用缓冲区减少IO操作次数，提升读写性能。

1. `bufio.NewScanner`: 

## flag包




# 模块管理

## 工作区

Go在1.18+版本后开始支持工作区Workspace模式，